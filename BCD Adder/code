module fulladder(x,y,z,S,C);
input x,y,z;
output S,C;
wire A;

xor(S,x,y,z);
assign C=x*y+x*z+y*z;

endmodule

module BCD_adder(x,y,S,C); //max value of op is 19
input [3:0]x,y;
output reg [3:0] S;
output [4:0] C;
assign C[0]=0;
assign e=4'b0110;

fulladder b0(x[0],y[0],C[0],S[0],C[1]);
fulladder b1(x[1],y[1],C[1],S[1],C[2]);
fulladder b2(x[2],y[2],C[2],S[2],C[3]);
fulladder b3(x[3],y[3],C[3],S[3],C[4]);

always@(S)
begin
if(S>9)
fulladder c0(S[0],e[0],C[0],S[0],C[1]);
fulladder c1(S[1],e[1],C[1],S[1],C[2]);
fulladder c2(S[2],e[2],C[2],S[2],C[3]);
fulladder c3(S[3],e[3],C[3],S[3],C[4]);
end
endmodule

`timescale 1ns/1ps
module BCD_adder_tb;
reg [3:0]x,y;
wire [3:0] S;
wire [4:0] C;

BCD_adder dut(.*);

initial begin 
x=0;y=0;

forever #5 x[0]=~x[0]; 
end

initial begin forever #10 x[1]=~x[1];  end
initial begin forever #20 x[2]=~x[2];  end
initial begin forever #40 x[3]=~x[3];  end
initial begin forever #2.5 y[0]=~y[0];  end
initial begin forever #5 y[1]=~y[2];  end
initial begin forever #10 y[2]=~y[2];  end
initial begin forever #20 y[3]=~y[3];  end
initial begin #100 $finish();
end
endmodule
